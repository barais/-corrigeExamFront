(()=>{"use strict";class ne{constructor(e){e?(this.alphabet="abcdefghijklmnopqrstuvwxyz",this.characters="0123456789"+this.alphabet.toUpperCase()+this.alphabet):this.characters="0123456789",this.isWarmedUp=this.loadModel(e).then().then(()=>console.info("Backend running on:",tf.getBackend()))}loadModel(e){return console.time("Load model"),e?tf.loadLayersModel("content/classifier/letteranddigitclassifier/model.json").then(a=>{this._model=a,console.timeEnd("Load model")}):tf.loadLayersModel("content/classifier/digitclassifier/model.json").then(a=>{this._model=a,console.timeEnd("Load model")})}warmUp(){console.time("Warmup"),this._model.predict(tf.randomNormal([1,28,28,1])).as1D().dataSync(),console.timeEnd("Warmup")}preprocessImage(e){const p=e.width>e.height,r=Math.round((Math.max(e.width,e.height)-Math.min(e.width,e.height))/2),u=p?[[r,r],[0,0],[0,0]]:[[0,0],[r,r],[0,0]];return tf.tidy(()=>{let o=tf.browser.fromPixels(e,1).pad(u,255);return o=tf.image.resizeBilinear(o,[24,24]).pad([[2,2],[2,2],[0,0]],255),o=tf.scalar(1).sub(o.toFloat().div(tf.scalar(255))),o.expandDims(0)})}predict(e){if(!this._model)return console.warn("Model not loaded yet!");const a=this.preprocessImage(e),l=this._model.predict(a).as1D(),v=l.argMax().dataSync()[0],p=l.max().dataSync()[0];return[this.characters[v],p]}}let le,ie;function ce(t,e){let a=cv.matFromImageData(t.payload.image);const l=function we(t){return t?(void 0===le&&(le=new ne(t)),le):(void 0===ie&&(ie=new ne(t)),ie)}(e);l.isWarmedUp.then(()=>{const v=function Me(t,e,a,l,v){const p=function Re(t,e,a){let s=t.clone(),I=new cv.Mat;cv.cvtColor(t,I,cv.COLOR_BGR2GRAY,0);let L=new cv.Mat;cv.threshold(I,L,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU);let G=new cv.Point(-1,-1);if(e){let d=new cv.Mat,k=new cv.Size(1,15),_=cv.getStructuringElement(cv.MORPH_RECT,k);cv.morphologyEx(L,d,cv.MORPH_OPEN,_,G,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let F=new cv.MatVector,n=new cv.Mat;cv.findContours(d,F,n,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let i=new cv.Scalar(255,255,255);cv.drawContours(s,F,-1,i,4);let c=new cv.Mat,h=new cv.Size(15,1),m=cv.getStructuringElement(cv.MORPH_RECT,h),B=new cv.Point(-1,-1);cv.morphologyEx(L,c,cv.MORPH_OPEN,m,B,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let y=new cv.MatVector,C=new cv.Mat;cv.findContours(c,y,C,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let A=new cv.Scalar(255,255,255);cv.drawContours(s,y,-1,A,4),d.delete(),F.delete(),n.delete(),_.delete(),c.delete(),y.delete(),C.delete(),m.delete()}let S=new cv.Size(3,3),M=cv.getStructuringElement(cv.MORPH_ELLIPSE,S),N=new cv.Mat,Y=cv.Mat.ones(t.rows,t.cols,cv.CV_8UC3);Y.setTo(new cv.Scalar(255,255,255)),cv.cvtColor(Y,Y,cv.COLOR_BGR2GRAY,0);let f=new cv.Mat;cv.cvtColor(s,f,cv.COLOR_BGR2GRAY,0);let P=new cv.Mat;cv.subtract(Y,f,P,N,-1);let E=new cv.Mat;cv.dilate(P,E,M,G,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let x=new cv.Mat,b=new cv.Mat;cv.bitwise_and(E,L,x),cv.morphologyEx(x,b,cv.MORPH_CLOSE,M,G,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let O=new cv.Mat;cv.bitwise_and(b,L,O);let z=new cv.Mat;cv.subtract(Y,O,z,N,-1);let R=new cv.MatVector,D=new cv.Mat;cv.findContours(O,R,D,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);const U=new Map;let w=[];for(let d=0;d<R.size();d++){let k=R.get(d),_=cv.boundingRect(k);(_.width>12||_.height>12)&&w.push(_)}let H=re(w),W=0;for(;null!==H&&W<200;)w=w.filter(d=>d!==H.toRemove1&&d!==H.toRemove2),w.push(H.u),H=re(w),W+=1;w.forEach(d=>{let k=new cv.Scalar(0,0,0),_=new cv.Point(d.x,d.y),F=new cv.Point(d.x+d.width,d.y+d.height),n=new cv.Mat,i=new cv.Mat,c=new cv.Mat,h=new cv.Scalar(255,0,0,255);n=$(z,d),d.width>d.height?cv.copyMakeBorder(n,n,(d.width-d.height)/2,(d.width-d.height)/2,1,1,cv.BORDER_CONSTANT,h):cv.copyMakeBorder(n,n,1,1,(d.height-d.width)/2,(d.height-d.width)/2,cv.BORDER_CONSTANT,h);let m=new cv.Size(26,26);cv.resize(n,i,m,0,0,cv.INTER_AREA),cv.copyMakeBorder(i,c,1,1,1,1,cv.BORDER_CONSTANT,h),U.set(d,c),n.delete(),i.delete(),cv.rectangle(z,_,F,k,2,cv.LINE_AA,0)}),I.delete(),L.delete(),M.delete(),N.delete(),Y.delete(),f.delete(),P.delete(),E.delete(),s.delete(),x.delete(),b.delete(),O.delete(),R.delete(),D.delete();let g=[...U];if(g.sort((d,k)=>d[0].x<k[0].x?-1:1),a&&g.length>3){const d=(g[g.length-1][0].x-g[0][0].x)/g.length;let k=d,_=0,F=0,n=800;const i=[];for(let h=0;h<g.length-1;h++){let m=g[h+1][0].x-g[h][0].x;m<k&&(k=m),m>1.7*d&&i.push(h),g[h][0].y<n&&(n=g[h][0].y),g[h][0].height>_&&(_=g[h][0].height),g[h][0].width>F&&(F=g[h][0].width)}const c=(g[g.length-1][0].x-g[0][0].x)/(g.length+i.length);i.forEach(h=>{let m=g[h][0].x+c,B=new cv.Scalar(0,0,0),y=new cv.Point(m,n),C=new cv.Point(m+F,n+_),A=new cv.Rect(m,n,F,_),V=new cv.Mat,K=new cv.Mat,J=new cv.Mat;V=$(z,A);let q=new cv.Size(26,26);cv.resize(V,K,q,0,0,cv.INTER_AREA);let Q=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(K,J,1,1,1,1,cv.BORDER_CONSTANT,Q),U.set(A,J),V.delete(),K.delete(),cv.rectangle(z,y,C,B,2,cv.LINE_AA,0)}),g=[...U],g.sort((h,m)=>h[0].x<m[0].x?-1:1)}return{letter:g,invert_final:z}}(t,!1,l);let r=[];e.forEach(o=>{r.push([o.padEnd(13," "),0])});const u=[];for(let o=0;o<p.letter.length;o++){let s=a.predict(j(p.letter[o][1]));v&&("1"===s[0]&&(s[0]="i"),"0"===s[0]&&(s[0]="o"),"5"===s[0]&&(s[0]="s"),"3"===s[0]&&(s[0]="b"),"9"===s[0]&&(s[0]="g")),u.push(s)}for(let o=0;o<r.length;o++){for(let s=0;s<13;s++)s<u.length&&(r[o][1]=r[o][0].substring(s,s+1).toLowerCase()===u[s][0].toLowerCase()?r[o][1]+u[s][1]:v?r[o][1]+(1-u[s][1])/35:r[o][1]+(1-u[s][1])/9);r[o][1]=r[o][1]/u.length}for(let o=0;o<r.length;o++)r[o][0]=r[o][0].trim(),r[o][1]=r[o][1]-Math.abs(r[o][0].length-u.length)/r[o][0].length;return r.sort((o,s)=>o[1]<s[1]?1:-1),{debug:p.invert_final,solution:r[0]}}(a,t.payload.match,l,!0,e);postMessage({msg:t.msg,payload:{debug:j(v.debug),solution:v.solution},uid:t.uid}),v.debug.delete(),a.delete()})}function j(t){const e=new cv.Mat,a=t.type()%8,l=a<=cv.CV_8S?1:a<=cv.CV_32S?1/256:255,v=a===cv.CV_8S||a===cv.CV_16S?128:0;switch(t.convertTo(e,cv.CV_8U,l,v),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const p=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),p}function $(t,e,a){const l=t.size().width,v=t.size().height;return e.x+e.width>l&&(e.width=l-e.x),e.y+e.height>v&&(e.height=v-e.y),e.x<0&&(e.x=0),e.y<0&&(e.y=0),t.roi(e)}function _e(t,e){let a=e,l=t,v=t,p=e;t.x>e.x&&(a=t,l=e),t.y>e.y&&(v=e,p=t),t.right=t.x+t.width,e.right=e.x+e.width,t.bottom=t.y+t.height,e.bottom=e.y+e.height;let r=e,u=t,o=e,s=t;return t.right>e.right&&(r=t,u=e),t.bottom>e.bottom&&(o=t,s=e),a.x<l.right&&p.y>v.y+v.height?new cv.Rect(l.x,s.y,r.right-l.x,o.bottom-v.y):a.x>l.x+l.width+5||p.y>v.y+v.height?null:new cv.Rect(l.x,s.y,r.right-l.x,o.bottom-v.y)}function re(t){for(let e=0;e<t.length-1;e++){const a=t[e];for(let l=e+1;l<t.length;l++){const v=t[l],p=_e(a,v);if(null!==p)return{u:p,toRemove1:a,toRemove2:v}}}return null}addEventListener("message",t=>{switch(t.data.msg){case"hello":postMessage({msg:`worker response to ${t.data.msg}`,uid:t.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(a=>{cv=a,a.ready.then(()=>postMessage({msg:"opencvready",uid:t.data.uid}))})}},e.importScripts(e.Module.scriptUrl),e.importScripts("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs");break}case"imageProcessing":return function me(t){const e=cv.matFromImageData(t.payload);let a=new cv.Mat;cv.cvtColor(e,a,cv.COLOR_BGR2GRAY),postMessage({msg:t.msg,payload:j(a),uid:t.uid}),e.delete(),a.delete()}(t.data);case"imageAlignement":return function ue(t){if(t.payload.marker){const e=function fe(t){let r,u,o,s,I,L,G,S,M,N,T,Y,e=cv.matFromImageData(t.imageA),a=new cv.Mat,l=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,l,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),l.cols>0&&(r=l.data32F[0],u=l.data32F[1],o=l.data32F[2],s=l.data32F[0],I=l.data32F[1],L=l.data32F[2],G=l.data32F[0],S=l.data32F[1],M=l.data32F[2],N=l.data32F[0],T=l.data32F[1],Y=l.data32F[2]);const f=e.size().width,P=e.size().height;if(l.cols>0)for(let n=1;n<l.cols;n++){let i=l.data32F[3*n],c=l.data32F[3*n+1],h=l.data32F[3*n+2];i*i+c*c<=r*r+u*u&&(r=i,u=c,o=h),i*i+c*c>=N*N+T*T&&(N=i,T=c,Y=h),(f-i)*(f-i)+c*c<=(f-s)*(f-s)+I*I&&(s=i,I=c,L=h),i*i+(P-c)*(P-c)<=G*G+(P-S)*(P-S)&&(G=i,S=c,M=h)}let E=cv.matFromImageData(t.imageB),x=new cv.Mat,b=new cv.Mat;cv.cvtColor(E,x,cv.COLOR_RGBA2GRAY);const O=x.size().width,z=x.size().height;cv.HoughCircles(x,b,cv.HOUGH_GRADIENT,1,45,75,15,M-3,M+3);let R=[],D=[];const U=180*(4*M*M-3.14159*M*M)/100;for(let n=0;n<b.cols;n++){let i=b.data32F[3*n],c=b.data32F[3*n+1];const h=i-M,m=c-M;let B=2*M,y=2*M;h+B>O&&(B=O-h),m+y>z&&(y=z-m);let C=new cv.Rect(i-M,c-M,B,y),A=new cv.Mat;A=$(x,C),cv.threshold(A,A,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(A)<U&&(R.push(i),D.push(c)),A.delete()}let w,H,W,g,d,k,_,F;if(R.length>0&&(w=R[0],H=D[1],W=R[0],g=D[1],d=R[0],k=D[1],_=R[0],F=D[1]),R.length>1)for(let n=0;n<R.length;n++){let i=R[n],c=D[n];i*i+c*c<=w*w+H*H&&(w=i,H=c),i*i+c*c>=_*_+F*F&&(_=i,F=c),(O-i)*(O-i)+c*c<=(O-W)*(O-W)+g*g&&(W=i,g=c),i*i+(z-c)*(z-c)<=d*d+(z-k)*(z-k)&&(d=i,k=c)}if(R.length>=4){let n=cv.matFromArray(4,1,cv.CV_32FC2,[r,u,s,I,G,S,N,T]),i=cv.matFromArray(4,1,cv.CV_32FC2,[w,H,W,g,d,k,_,F]),c=cv.findHomography(i,n,cv.RANSAC),h=new cv.Size(e.cols,e.rows);if(c.empty())return void console.log("homography matrix empty!");cv.warpPerspective(E,a,c,h);let m=a.clone();for(let y=0;y<i.rows;++y){let V=15,K=new cv.Point(i.data32F[2*y],i.data32F[2*y+1]);cv.circle(E,K,V,[0,0,255,255],1)}for(let y=0;y<n.rows;++y){let V=15,K=new cv.Point(n.data32F[2*y],n.data32F[2*y+1]);cv.circle(e,K,V,[0,0,255,255],1),cv.circle(m,K,V,[0,0,255,255],1)}let B={};return B.imageAligned=j(m),B.imageAlignedWidth=m.size().width,B.imageAlignedHeight=m.size().height,e.delete(),a.delete(),l.delete(),x.delete(),E.delete(),b.delete(),n.delete(),i.delete(),m.delete(),B}{let n=new cv.KeyPointVector,i=new cv.KeyPointVector,c=new cv.Mat,h=new cv.Mat,m=new cv.AKAZE,B=new cv.Mat,y=new cv.Mat;m.detectAndCompute(x,B,n,c),m.detectAndCompute(e,y,i,h);let C=new cv.DMatchVector,A=new cv.BFMatcher,V=new cv.DMatchVectorVector;A.knnMatch(c,h,V,2);for(let X=0;X<V.size();++X){let ve=V.get(X),ge=ve.get(0),Ce=ve.get(1);ge.distance<=Ce.distance*parseFloat("0.7")&&C.push_back(ge)}let K=new cv.Mat,J=new cv.Scalar(0,255,0,255);cv.drawMatches(E,n,e,i,C,K,J);let q={},Q=new cv.Mat,se=new cv.Mat,de=new cv.Scalar(0,255,0,255);cv.drawKeypoints(x,n,Q,de),cv.drawKeypoints(e,i,se,de);let ee=[],te=[];for(let X=0;X<C.size();X++)ee.push(n.get(C.get(X).queryIdx).pt.x),ee.push(n.get(C.get(X).queryIdx).pt.y),te.push(i.get(C.get(X).trainIdx).pt.x),te.push(i.get(C.get(X).trainIdx).pt.y);let ae=new cv.Mat(ee.length,1,cv.CV_32FC2);ae.data32F.set(ee);let oe=new cv.Mat(te.length,1,cv.CV_32FC2);oe.data32F.set(te);let he=cv.findHomography(ae,oe,cv.RANSAC);if(he.empty())return void console.log("homography matrix empty!");let Z=new cv.Mat;return cv.warpPerspective(x,Z,he,e.size()),q.imageAligned=j(Z),q.imageAlignedWidth=Z.size().width,q.imageAlignedHeight=Z.size().height,Z.delete(),ae.delete(),oe.delete(),Q.delete(),se.delete(),K.delete(),V.delete(),A.delete(),C.delete(),m.delete(),n.delete(),i.delete(),c.delete(),h.delete(),B.delete(),y.delete(),e.delete(),a.delete(),l.delete(),x.delete(),E.delete(),b.delete(),q}}(t.payload);postMessage({msg:t.msg,payload:e,uid:t.uid})}else{const e=function ye(t,e){let a=cv.matFromImageData(t),l=cv.matFromImageData(e),v=new cv.Mat,p=new cv.Mat;cv.cvtColor(l,v,cv.COLOR_BGRA2GRAY),cv.cvtColor(a,p,cv.COLOR_BGRA2GRAY);let r=new cv.KeyPointVector,u=new cv.KeyPointVector,o=new cv.Mat,s=new cv.Mat,I=new cv.AKAZE,L=new cv.Mat,G=new cv.Mat;I.detectAndCompute(v,L,r,o),I.detectAndCompute(p,G,u,s);let S=new cv.DMatchVector,M=new cv.BFMatcher,N=new cv.DMatchVectorVector;M.knnMatch(o,s,N,2);for(let w=0;w<N.size();++w){let H=N.get(w),W=H.get(0),g=H.get(1);W.distance<=g.distance*parseFloat("0.7")&&S.push_back(W)}let T=new cv.Mat,Y=new cv.Scalar(0,255,0,255);cv.drawMatches(l,r,a,u,S,T,Y);let f={};f.imageCompareMatches=j(T),f.imageCompareMatchesWidth=T.size().width,f.imageCompareMatchesHeight=T.size().height;let P=new cv.Mat,E=new cv.Mat,x=new cv.Scalar(0,255,0,255);cv.drawKeypoints(v,r,P,x),cv.drawKeypoints(p,u,E,x),f.keypoints1=j(P),f.keypoints1Width=P.size().width,f.keypoints1Height=P.size().height,f.keypoints2=j(E),f.keypoints2Width=E.size().width,f.keypoints2Height=E.size().height;let b=[],O=[];for(let w=0;w<S.size();w++)b.push(r.get(S.get(w).queryIdx).pt.x),b.push(r.get(S.get(w).queryIdx).pt.y),O.push(u.get(S.get(w).trainIdx).pt.x),O.push(u.get(S.get(w).trainIdx).pt.y);let z=new cv.Mat(b.length,1,cv.CV_32FC2);z.data32F.set(b);let R=new cv.Mat(O.length,1,cv.CV_32FC2);R.data32F.set(O);let D=cv.findHomography(z,R,cv.RANSAC);if(D.empty())return void console.log("homography matrix empty!");console.log("h:",D);let U=new cv.Mat;return cv.warpPerspective(l,U,D,a.size()),f.imageAligned=j(U),f.imageAlignedWidth=U.size().width,f.imageAlignedHeight=U.size().height,U.delete(),z.delete(),R.delete(),P.delete(),E.delete(),T.delete(),N.delete(),M.delete(),S.delete(),I.delete(),v.delete(),r.delete(),p.delete(),u.delete(),o.delete(),s.delete(),L.delete(),G.delete(),f}(t.payload.imageA,t.payload.imageB);postMessage({msg:t.msg,payload:e,uid:t.uid})}}(t.data);case"imageCrop":return function pe(t){let e=new cv.Rect(t.payload.x,t.payload.y,t.payload.width,t.payload.height),a=new cv.Mat,l=cv.matFromImageData(t.payload.image);a=$(l,e),postMessage({msg:t.msg,payload:j(a),uid:t.uid}),a.delete(),l.delete()}(t.data);case"nameprediction":return ce(t.data,!0);case"ineprediction":return ce(t.data,!1)}})})();